"""
Unit tests for ShogiGame class in shogi_game.py using mock utilities.

This version updates the original test_shogi_game.py to use the mock utilities pattern
for better coverage and reliability.
"""

import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, Optional

import numpy as np
import pytest

# Add proper import path handling
if __name__ == "__main__":
    REPO_ROOT = Path(__file__).parent.parent.absolute()
    if str(REPO_ROOT) not in sys.path:
        sys.path.insert(0, str(REPO_ROOT))

# pylint: disable=wrong-import-position
from tests.mock_utilities import setup_pytorch_mock_environment


@dataclass
class GameState:
    """Helper class to store a snapshot of the game state."""

    board_str: str
    current_player: Optional[str] = None  # Store as string name of Color enum
    move_count: int = 0
    black_hand: Dict[str, int] = field(
        default_factory=dict
    )  # Storing .name of PieceType
    white_hand: Dict[str, int] = field(
        default_factory=dict
    )  # Storing .name of PieceType

    @classmethod
    def from_game(cls, game):
        """Creates a GameState snapshot from a ShogiGame instance."""
        with setup_pytorch_mock_environment():
            # pylint: disable=import-outside-toplevel
            from keisei.shogi.shogi_core_definitions import (
                Color,
            )  # PieceType only used in loop

            black_hand_str = {
                pt.name: count for pt, count in game.hands[Color.BLACK.value].items()
            }
            white_hand_str = {
                pt.name: count for pt, count in game.hands[Color.WHITE.value].items()
            }

            return cls(
                board_str=game.to_string(),
                current_player=game.current_player.name,
                move_count=game.move_count,
                black_hand=black_hand_str,
                white_hand=white_hand_str,
            )


@pytest.fixture
def new_game():
    """Creates a new standard game."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game import ShogiGame

        return ShogiGame()


@pytest.fixture
def game_with_black_pawn_in_hand():
    """Creates a game with one black pawn in hand (captured from White)."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game import ShogiGame
        from keisei.shogi.shogi_core_definitions import Piece, PieceType, Color

        game = ShogiGame()
        # To add a PAWN to Black's hand, it must have been a White PAWN that was captured.
        captured_white_pawn = Piece(PieceType.PAWN, Color.WHITE)
        game.add_to_hand(
            captured_white_pawn, Color.BLACK
        )  # Black captured White's pawn
        return game


@pytest.fixture
def game_with_white_rook_in_hand():
    """Creates a game with one white rook in hand (captured from Black)."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game import ShogiGame
        from keisei.shogi.shogi_core_definitions import Piece, PieceType, Color

        game = ShogiGame()
        # To add a ROOK to White's hand, it must have been a Black ROOK that was captured.
        captured_black_rook = Piece(PieceType.ROOK, Color.BLACK)
        game.add_to_hand(
            captured_black_rook, Color.WHITE
        )  # White captured Black's rook
        return game


@pytest.fixture
def game_with_mixed_hands():
    """Creates a game with multiple pieces in both players' hands."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game import ShogiGame
        from keisei.shogi.shogi_core_definitions import Piece, PieceType, Color

        game = ShogiGame()

        # Add pieces to Black's hand (captured from White)
        captured_white_pawn = Piece(PieceType.PAWN, Color.WHITE)
        for _ in range(3):
            game.add_to_hand(captured_white_pawn, Color.BLACK)

        captured_white_lance = Piece(PieceType.LANCE, Color.WHITE)
        game.add_to_hand(captured_white_lance, Color.BLACK)

        captured_white_bishop = Piece(PieceType.BISHOP, Color.WHITE)
        game.add_to_hand(captured_white_bishop, Color.BLACK)

        # Add pieces to White's hand (captured from Black)
        captured_black_pawn = Piece(PieceType.PAWN, Color.BLACK)
        for _ in range(2):
            game.add_to_hand(captured_black_pawn, Color.WHITE)

        captured_black_knight = Piece(PieceType.KNIGHT, Color.BLACK)
        game.add_to_hand(captured_black_knight, Color.WHITE)

        captured_black_silver = Piece(PieceType.SILVER, Color.BLACK)
        game.add_to_hand(captured_black_silver, Color.WHITE)

        return game


@pytest.fixture
def game_with_move_count_5():
    """Creates a game with move count 5."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game import ShogiGame

        game = ShogiGame()
        game.move_count = 5  # Directly setting for test purposes
        return game


def test_get_observation_initial_state_dimensions():
    """Test the dimensions of the observation from the initial state."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game import ShogiGame
        from keisei.shogi.shogi_game_io import generate_neural_network_observation

        game = ShogiGame()
        obs = generate_neural_network_observation(game)

        assert obs.shape == (46, 9, 9), "Observation shape should be (46, 9, 9)"


def test_get_observation_hand_pieces_black_one_pawn(game_with_black_pawn_in_hand):
    """Test observation channel for Black's hand containing one pawn."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game_io import generate_neural_network_observation
        from keisei.shogi.shogi_core_definitions import (
            OBS_CURR_PLAYER_HAND_START,
            PieceType,  # Make sure PieceType is imported if used directly
            # Assuming get_unpromoted_types() or a similar list is used internally by generate_neural_network_observation
            # to determine the index of PieceType.PAWN for hand piece planes.
            # For this test, we'll assume an ordering. Let's find PAWN's index if hand_piece_order is standard.
            get_unpromoted_types,
        )

        game = game_with_black_pawn_in_hand
        # Ensure current player is Black for OBS_CURR_PLAYER_HAND_START to apply to Black's hand
        game.current_player = (
            game.current_player.BLACK
        )  # Assuming Color enum from shogi_core_definitions

        obs = generate_neural_network_observation(game)

        hand_piece_order = get_unpromoted_types()  # P, L, N, S, G, B, R
        pawn_idx_in_hand_order = -1
        for i, pt in enumerate(hand_piece_order):
            if pt == PieceType.PAWN:
                pawn_idx_in_hand_order = i
                break
        assert (
            pawn_idx_in_hand_order != -1
        ), "Pawn not found in hand piece order for observation"

        pawn_plane_idx = OBS_CURR_PLAYER_HAND_START + pawn_idx_in_hand_order

        # The assertion value (1/18) depends on the normalization in generate_neural_network_observation
        assert np.all(
            obs[pawn_plane_idx] == 1 / 18.0
        ), "Pawn in Black's hand not correctly represented"


def test_get_observation_hand_pieces_white_one_rook(game_with_white_rook_in_hand):
    """Test observation channel for White's hand containing one rook."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game_io import generate_neural_network_observation
        from keisei.shogi.shogi_core_definitions import (
            OBS_OPP_PLAYER_HAND_START,  # If Black is current player, White is opponent
            PieceType,
            get_unpromoted_types,
            Color,
        )

        game = game_with_white_rook_in_hand
        # To test White's hand as opponent, Black should be the current player
        game.current_player = Color.BLACK

        obs = generate_neural_network_observation(game)

        hand_piece_order = get_unpromoted_types()
        rook_idx_in_hand_order = -1
        for i, pt in enumerate(hand_piece_order):
            if pt == PieceType.ROOK:
                rook_idx_in_hand_order = i
                break
        assert (
            rook_idx_in_hand_order != -1
        ), "Rook not found in hand piece order for observation"

        rook_plane_idx = OBS_OPP_PLAYER_HAND_START + rook_idx_in_hand_order

        # This assertion value depends on normalization. Your previous test had 1/2.
        # shogi_game_io.py used 1/18. I will use 1/18 for consistency with your io file.
        # If it should be 1/2, your generate_neural_network_observation needs adjustment.
        assert np.all(
            obs[rook_plane_idx] == 1 / 18.0
        ), "Rook in White's hand not correctly represented"


def test_get_observation_multiple_hand_pieces_mixed_players(game_with_mixed_hands):
    """Test observation channels for multiple pieces in both players' hands."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game_io import generate_neural_network_observation
        from keisei.shogi.shogi_core_definitions import (
            OBS_CURR_PLAYER_HAND_START,
            OBS_OPP_PLAYER_HAND_START,
            PieceType,
            get_unpromoted_types,
            Color,
        )

        game = game_with_mixed_hands
        game.current_player = Color.BLACK  # Set current player to Black for consistency

        obs = generate_neural_network_observation(game)

        hand_piece_order = get_unpromoted_types()
        pawn_idx = hand_piece_order.index(PieceType.PAWN)
        lance_idx = hand_piece_order.index(PieceType.LANCE)
        bishop_idx = hand_piece_order.index(PieceType.BISHOP)
        knight_idx = hand_piece_order.index(PieceType.KNIGHT)
        silver_idx = hand_piece_order.index(PieceType.SILVER)

        # Check Black's hand (current player)
        curr_pawn_plane = OBS_CURR_PLAYER_HAND_START + pawn_idx
        curr_lance_plane = OBS_CURR_PLAYER_HAND_START + lance_idx
        curr_bishop_plane = OBS_CURR_PLAYER_HAND_START + bishop_idx

        # Normalization from shogi_game_io.py is count / 18.0
        assert np.all(obs[curr_pawn_plane] == 3 / 18.0), "Black's 3 pawns not correct"
        assert np.all(obs[curr_lance_plane] == 1 / 18.0), "Black's 1 lance not correct"
        assert np.all(
            obs[curr_bishop_plane] == 1 / 18.0
        ), "Black's 1 bishop not correct"

        # Check White's hand (opponent player)
        opp_pawn_plane = OBS_OPP_PLAYER_HAND_START + pawn_idx
        opp_knight_plane = OBS_OPP_PLAYER_HAND_START + knight_idx
        opp_silver_plane = OBS_OPP_PLAYER_HAND_START + silver_idx

        assert np.all(obs[opp_pawn_plane] == 2 / 18.0), "White's 2 pawns not correct"
        assert np.all(obs[opp_knight_plane] == 1 / 18.0), "White's 1 knight not correct"
        assert np.all(obs[opp_silver_plane] == 1 / 18.0), "White's 1 silver not correct"


def test_get_observation_empty_hands(new_game):
    """Test observation shows empty hands in initial game state."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game_io import generate_neural_network_observation
        from keisei.shogi.shogi_core_definitions import (
            OBS_CURR_PLAYER_HAND_START,
            OBS_OPP_PLAYER_HAND_START,
        )

        obs = generate_neural_network_observation(new_game)

        for i in range(7):  # 7 piece types that can be in hand
            curr_plane_idx = OBS_CURR_PLAYER_HAND_START + i
            opp_plane_idx = OBS_OPP_PLAYER_HAND_START + i
            assert np.all(
                obs[curr_plane_idx] == 0
            ), f"Hand plane {curr_plane_idx} should be empty"
            assert np.all(
                obs[opp_plane_idx] == 0
            ), f"Hand plane {opp_plane_idx} should be empty"


def test_get_observation_current_player_plane_black_turn(new_game):
    """Test current player indicator for Black's turn."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game_io import generate_neural_network_observation
        from keisei.shogi.shogi_core_definitions import OBS_CURR_PLAYER_INDICATOR, Color

        new_game.current_player = Color.BLACK  # Ensure it's Black's turn
        obs = generate_neural_network_observation(new_game)

        assert np.all(
            obs[OBS_CURR_PLAYER_INDICATOR] == 1.0
        ), "Current player indicator should be all 1.0s for Black's turn"


def test_get_observation_current_player_plane_white_turn():
    """Test current player indicator for White's turn."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game import ShogiGame
        from keisei.shogi.shogi_game_io import generate_neural_network_observation
        from keisei.shogi.shogi_core_definitions import OBS_CURR_PLAYER_INDICATOR, Color

        game = ShogiGame()
        game.current_player = Color.WHITE  # Set to White's turn

        obs = generate_neural_network_observation(game)

        assert np.all(
            obs[OBS_CURR_PLAYER_INDICATOR] == 0.0
        ), "Current player indicator should be all 0.0s for White's turn"


def test_get_observation_move_count_plane(game_with_move_count_5):
    """Test move count plane reflects the correct move count."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game_io import generate_neural_network_observation
        from keisei.shogi.shogi_core_definitions import OBS_MOVE_COUNT

        game = game_with_move_count_5
        obs = generate_neural_network_observation(game)

        # Normalized by game.max_moves_per_game as per shogi_game_io.py
        expected_value = (
            game.move_count / game.max_moves_per_game
            if game.max_moves_per_game > 0
            else 0.0
        )
        assert np.all(
            obs[OBS_MOVE_COUNT] == expected_value
        ), f"Move count plane incorrect. Expected {expected_value}, got {obs[OBS_MOVE_COUNT][0,0]}"


def test_get_observation_board_pieces_consistency_after_reset(new_game):
    """Test observation consistency after a game reset."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game_io import generate_neural_network_observation

        # OBS constants are used for slicing, ensure they are correct and cover board pieces
        # For simplicity, comparing the whole observation might be easier if reset truly restores everything.
        # Or compare specific known piece planes.

        obs_initial = generate_neural_network_observation(new_game)

        new_game.make_move((6, 4, 5, 4, False))
        new_game.make_move((2, 4, 3, 4, False))

        new_game.reset()
        obs_after_reset = generate_neural_network_observation(new_game)

        # Compare all board piece planes (0-27 typically for current and opponent pieces)
        # and meta planes like current player indicator. Hand planes should also be empty for both.
        np.testing.assert_array_equal(
            obs_initial,
            obs_after_reset,
            "Observation should be identical after reset to initial state",
        )


def test_get_observation_promoted_piece_on_board():
    """Test observation contains the promoted piece correctly."""
    with setup_pytorch_mock_environment():
        # pylint: disable=import-outside-toplevel
        from keisei.shogi.shogi_game import ShogiGame
        from keisei.shogi.shogi_core_definitions import Piece, PieceType, Color
        from keisei.shogi.shogi_game_io import generate_neural_network_observation
        from keisei.shogi.shogi_core_definitions import (
            OBS_CURR_PLAYER_PROMOTED_START,
            OBS_PROMOTED_ORDER,  # List of promoted PieceType enums
        )

        game = ShogiGame()
        game.current_player = Color.BLACK  # Assuming the piece is Black's

        promoted_rook = Piece(PieceType.PROMOTED_ROOK, Color.BLACK)
        game.set_piece(4, 4, promoted_rook)  # Manually set piece for testing

        obs = generate_neural_network_observation(game)

        # Find the index of PROMOTED_ROOK in the OBS_PROMOTED_ORDER list
        promoted_rook_idx_in_order = -1
        for i, pt in enumerate(OBS_PROMOTED_ORDER):
            if pt == PieceType.PROMOTED_ROOK:
                promoted_rook_idx_in_order = i
                break
        assert (
            promoted_rook_idx_in_order != -1
        ), "PROMOTED_ROOK not in OBS_PROMOTED_ORDER"

        rook_plane_idx = OBS_CURR_PLAYER_PROMOTED_START + promoted_rook_idx_in_order

        assert (
            obs[rook_plane_idx, 4, 4] == 1.0
        ), f"Promoted rook not found at obs[{rook_plane_idx}, 4, 4]"
        # Check other cells in this plane are zero
        expected_plane = np.zeros((9, 9), dtype=np.float32)
        expected_plane[4, 4] = 1.0
        np.testing.assert_array_equal(
            obs[rook_plane_idx],
            expected_plane,
            "Promoted rook plane has unexpected values.",
        )


if __name__ == "__main__":
    pytest.main(["-xvs", __file__])
